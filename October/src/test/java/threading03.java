package src.test.java;

/**
 * 该类是用来测试 volatile关键字 的 volatile 翻译为 : 可变化的 容易变的
 * volatile关键字能够保证内存可见性
 * volatile修饰的变量能够保证"内存可见性"
 *    代码在写入 volatile 关键字修饰变量的时候
 *      1.改变线程工作中 volatile 变量副本的值
 *      2.将改变后的副本的值从工作内存中刷新到主内存
 *
 *      代码在读取volatile 修饰的变量的时候
 *       1. 从主内存中读取的volatile 变量的最新的值到线程的工作内存总
 *       2. 从工作内存中读取volatile变量的副本
 *
 *       线程不安全的原因 : 内存可见性的问题
 *       eg : 一个线程负责读数据,一个线程负责写数据
 *       由于编译器的优化机制就可能会在多线程环境下出现问题,而在多线程下出现问题的话,那么此时就代表线程不安全
 *
 *       而我们的线程不安全的原因分别有  :
 *       1) 操作系统对线程的调度是抢占式执行/随机的
 *       2) 多个线程,修改同一个变量
 *       3) 修改操作 不是原子性的
 *       4) 内存可见性
 *       5) 指令重排序
 *
 *
 *       那么我们这里的内存可见性带来的线程不安全是如何解决的呢? 也就是我们接下来需要讲的主角了. volatile
 */
 public class threading03{
     static class Counter{
         public int count = 0;

         public Counter(){

         }
     }
     public static void main(String[] args){
         Counter counter = new Counter();

         /**
          * 这个线程的run方法里面的逻辑就只有读数据
          */
         Thread thread1 = new Thread(()->{
            while(counter.count == 0){ //这里的操作只有LOAD操作,也就是只有读数据,这个数据在哪里读呢 ? 在内存中读
            /*
            我们知道这里的代码只会进行两种操作 : LOAD  读内存 ;
            和 CMP : 进行比较寄存器中的值是否为 0

             1. 疑问这里的读LOAD 和 COM (比较寄存器中的值是否为0 ,那个消耗的时间长?)
             答 : 必然是 LOAD 消耗的时间更加的长,并且 比CMP满了3-5 个数量级

             2. 计算机中可以存数据的有 cpu,内存,硬盘 ,他们读数据的速度是怎样的关系 ?
              cpu > 内存 > 硬盘
              既然你一直在进行LOAD操作,而且在这个过程中没有进行修改操作,意思就是编译器发现你频繁的进行LOAD操作,不仅每次的LOAD的值相同,
              且没有进行写的操作,那么就只执行了一次的LOAD操作,后续就进行CMP的时候就不再重复的读内存了.

              3.因为没有别人进行写这个代码,那么编译器就做了一个大胆的决定,只读一次,后面就不继续读了,效率大大提升 !
              那么在编译器做了优化的条件下,如果我们又加入一个线程,并且这个线程是进行写操作的,那么又会发生怎样的变化呢?
             */
            }
        });

         Thread Thread2 = new Thread(()->{
            //这个线程先暂时什么都不做
         });
     }
 }